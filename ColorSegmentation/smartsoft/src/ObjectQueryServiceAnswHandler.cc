//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "ObjectQueryServiceAnswHandler.hh"
#include "ColorSegmentation.hh"

ObjectQueryServiceAnswHandler::ObjectQueryServiceAnswHandler(Smart::IQueryServerPattern<CommPerception::CommInfDetection, CommPerception::CommObjectProperties, SmartACE::QueryId>* server)
:	ObjectQueryServiceAnswHandlerCore(server)
{
	
}

ObjectQueryServiceAnswHandler::~ObjectQueryServiceAnswHandler()
{
	
}


void ObjectQueryServiceAnswHandler::handleQuery(const SmartACE::QueryId &id, const CommPerception::CommInfDetection& request) 
{
	CommPerception::CommObjectProperties answer;
	answer.setIs_valid(false);
	// implement your query handling logic here and fill in the answer object


	if(COMP->newestImageStatus == Smart::SMART_OK){

		//Check color
		CommPerception::Color color;
		CommPerception::HSVSpace min_range = request.getColor().getMin_range(), max_range = request.getColor().getMax_range();
		if(min_range.getH() == 0 && min_range.getS() == 0 && min_range.getV() == 0 ){
			if(max_range.getH() == 0 && max_range.getS() == 0 && max_range.getV() == 0 ){
				color = COMP->getColor(request.getColor().getName());
				std::cout<< "[ColorQueryService] using default values of color : "<<request.getColor().getName()<<std::endl;
			}
		}
		else
			color = request.getColor();

		CommPerception::ROI roiFixed;
		CommPerception::CommPoint2d cpoint;
		cv::Mat image = COMP->getMat(COMP->newestImage), subImg;
//		cv::imwrite("completeiamge.png", image);

		if(request.getRoi().getWidth() * request.getRoi().getHeight() == 0 ){
			subImg = image;
			std::cout<< "[ColorQueryService] ROI not available "<<std::endl;
		}else{
			std::cout<< "[ColorQueryService] using ROI : "<<request.getRoi().getWidth() <<" - "<<request.getRoi().getHeight() <<std::endl;
			roiFixed = fixROI(request.getRoi(), image.size().width, image.size().height);
			subImg = image(cv::Range(roiFixed.getPoint().getY(), roiFixed.getPoint().getY() + roiFixed.getHeight()),
					cv::Range(roiFixed.getPoint().getX() , roiFixed.getPoint().getX() + roiFixed.getWidth()));   //TODO
		}
//		cv::imwrite("subimage.png", subImg);

		cv::Mat mask = COMP->segmentation(subImg, color);
//		cv::imwrite("maskimage.png", mask);

		double min, max;
		cv::minMaxLoc(mask, &min, &max);
		if (max > 0)
		{

			cv::Point p_object = COMP->countour(mask);
			if(request.getRoi().getWidth() *request.getRoi().getHeight() != 0 ){
				p_object.x += roiFixed.getPoint().getX() ;
				p_object.y += roiFixed.getPoint().getY() ;
			}
			answer.setIs_valid(true);
			cpoint.setX(p_object.x);
			cpoint.setY(p_object.y);

			answer.setPoint2d(cpoint);

		}
		else
			std::cout<< "[ColorQueryService] Object not detected "<<std::endl;
	}
	else
		std::cout<< "[ColorQueryService] Failed attempt, no images of the sensor were received"<<std::endl;

	this->server->answer(id, answer);

}

CommPerception::ROI ObjectQueryServiceAnswHandler::fixROI(CommPerception::ROI input, int image_width, int image_height )
{//(a<b?a:b);

	CommPerception::ROI roi_fixed;
	CommPerception::CommPoint2d point;

	point.setX(input.getPoint().getX() < 0 ? 0:input.getPoint().getX());
	point.setY(input.getPoint().getY() < 0 ? 0:input.getPoint().getY());
	roi_fixed.setPoint(point);

	int roi_width = input.getPoint().getX() + input.getWidth() <= image_width - 1? \
			input.getWidth() : image_width - input.getPoint().getX() - 1;
	int roi_height = input.getPoint().getY() + input.getHeight() <= image_height - 1?\
			input.getHeight() : image_height - input.getPoint().getY() - 1;
	roi_fixed.setWidth(roi_width);
	roi_fixed.setHeight(roi_height);

	std::cout<< "[ColorQueryService-fixROI] image  width:"<< image_width <<\
			", height:"<<image_height<<std::endl;

	std::cout<< "[ColorQueryService-fixROI] oldROI  x:"<<input.getPoint().getX()<<\
			", y:"<<input.getPoint().getY()<<\
			", width:"<<input.getWidth()<<\
			", height:"<<input.getHeight()<<std::endl;

	std::cout<< "[ColorQueryService-fixROI] newROI  x:"<<roi_fixed.getPoint().getX()<<\
			", y:"<<roi_fixed.getPoint().getY()<<\
			", width:"<<roi_fixed.getWidth()<<\
			", height:"<<roi_fixed.getHeight()<<std::endl;

	return roi_fixed;

}
