//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "CaptureSensor.hh"
#include "ObjectLocation.hh"

#include <iostream>

CaptureSensor::CaptureSensor(SmartACE::SmartComponent *comp) 
:	CaptureSensorCore(comp)
{
	std::cout << "constructor CaptureSensor\n";
}
CaptureSensor::~CaptureSensor() 
{
	std::cout << "destructor CaptureSensor\n";
}



int CaptureSensor::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	return 0;
}
int CaptureSensor::on_execute()
{
	Smart::StatusCode status;

	//pcl::fromPCLPointCloud2(*cloud_in, *cloud_helper);
	PointCloud transformed_cloud, cloud_process; // transformed cloud
	PointCloud::Ptr filter_cloud (new PointCloud), filter1_cloud (new PointCloud), filter2_cloud (new PointCloud), objects_cloud (new PointCloud);

	// Step2: Crop table, robot and walls
	filter_passthrough(cloud_helper, filter1_cloud);
	filter_removeoutliers(filter1_cloud, filter_cloud);
	filter_voxel(filter_cloud, filter2_cloud);

	//viewer.showCloud (filter2_cloud);

	// Step3: Planar extraction and get the objects in different clusters
	extract_planar(filter2_cloud, objects_cloud);
	std::vector<pcl::PointCloud<pcl::PointXYZ>::Ptr> obj_clusters = get_clusters(objects_cloud);

	obj_pos_list.clear();
	for (std::size_t i = 0; i < obj_clusters.size(); ++i)
	{
		CommBasicObjects::CommPosition3d pos_cluster = get_pose(obj_clusters[i]);
		obj_pos_list.push_back(pos_cluster);
	}

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int CaptureSensor::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}


void CaptureSensor::filter_removeoutliers(PointCloud::Ptr cloud_in, PointCloud::Ptr cloud_out) {
	pcl::StatisticalOutlierRemoval<pcl::PointXYZ> sor;
	  sor.setInputCloud (cloud_in);
	  sor.setMeanK (50);
	  sor.setStddevMulThresh (0.3);//1.0
	  sor.filter (*cloud_out);
}

void CaptureSensor::filter_passthrough(PointCloud cloud_in, PointCloud::Ptr cloud_out) {
    PointCloud::Ptr cloud_ptr  = cloud_in.makeShared();
    pcl::PassThrough<pcl::PointXYZ> pass;

    // filter z
    pass.setInputCloud (cloud_ptr);
    pass.setFilterFieldName ("z");
    pass.setFilterLimits (_crop_min_z, _crop_max_z);
    pass.filter (*cloud_out);

    // //     // x: depth
    pass.setInputCloud (cloud_out);
    pass.setFilterFieldName ("x");
    pass.setFilterLimits (-_crop_depth, _crop_depth);
    pass.filter (*cloud_out);
    // y: width
    pass.setInputCloud (cloud_out);
    pass.setFilterFieldName ("y");
    pass.setFilterLimits (-_crop_width, _crop_width);
    pass.filter (*cloud_out);


    std::cout<<"[filter_passthrough] Initial points " << cloud_in.points.size() << " - Final points  " << cloud_out->points.size()<<std::endl;
}

void CaptureSensor::filter_voxel(PointCloud::Ptr  cloud_in, PointCloud::Ptr cloud_out) {
	pcl::VoxelGrid<pcl::PointXYZ> sor;
	sor.setInputCloud(cloud_in);
	sor.setLeafSize(_leaf_size, _leaf_size, _leaf_size);
	sor.filter(*cloud_out);

	std::cout<<"[filter_voxel] Initial points " << cloud_in->points.size() << " - Final points  " << cloud_out->points.size()<<std::endl;
}


void CaptureSensor::extract_planar(PointCloud::Ptr  cloud_in, PointCloud::Ptr cloud_out) {

  pcl::SACSegmentation<pcl::PointXYZ> seg;
  pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
  pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);
  pcl::PointCloud<pcl::PointXYZ>::Ptr cloudObj(new pcl::PointCloud<pcl::PointXYZ>());

  seg.setOptimizeCoefficients(true);
  seg.setModelType(pcl::SACMODEL_PLANE);
  seg.setMethodType(pcl::SAC_RANSAC);
  seg.setMaxIterations(100);
  seg.setDistanceThreshold(0.02);

  // int i = 0, nr_points = static_cast<int>(cloud_after_z->points.size());

  // while (i < 5) // 0.3 * nr_points
  // {
    // Segment the largest planar component from the remaining cloud
    seg.setInputCloud(cloud_in);
    seg.segment(*inliers, *coefficients);
    if (inliers->indices.size() == 0)
    {
    //  ROS_WARN("Could not estimate a planar model for the given dataset.");
      // break;
      return;
    }
    else
    {
     // ROS_DEBUG_STREAM_THROTTLE(1, "Segmentation: " << inliers->indices.size());
    }

    // Extract the planar inliers from the input cloud
    pcl::ExtractIndices<pcl::PointXYZ> extract;
    extract.setInputCloud(cloud_in);
    extract.setIndices(inliers);
    extract.setNegative(true);

    // Get the points associated with objects
    extract.filter(*cloud_out);
   // ROS_DEBUG_STREAM_THROTTLE(
     //   1, "PointCloud representing the planar component: " << cloud_out->points.size () << " data points." );

  //   ++i;
  // }

   std::cout<<"[extract_planar] Initial points " << cloud_in->points.size() << " - Final points  " << cloud_out->points.size()<< std::endl;
}

std::vector<pcl::PointCloud<pcl::PointXYZ>::Ptr> CaptureSensor::get_clusters(PointCloud::Ptr  cloud_in) {
  // Creating the KdTree object for the search method of the extraction
  pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);
  tree->setInputCloud(cloud_in);

  std::vector<pcl::PointIndices> cluster_indices;
  pcl::EuclideanClusterExtraction<pcl::PointXYZ> ec;
  ec.setClusterTolerance(0.02); // 2cm
  ec.setMinClusterSize(15);
  ec.setMaxClusterSize(25000);
  ec.setSearchMethod(tree);
  ec.setInputCloud(cloud_in);
  ec.extract(cluster_indices);

 // ROS_INFO_STREAM("[get_clusters] " << cluster_indices.size() << " detected  ");

  // Put clusters in a pointcloud vector
  std::vector<pcl::PointCloud<pcl::PointXYZ>::Ptr> objCluster(cluster_indices.size());
  for (std::size_t i = 0; i < cluster_indices.size(); ++i)
  {
    objCluster[i].reset(new pcl::PointCloud<pcl::PointXYZ>());
    objCluster[i]->points.reserve(cluster_indices[i].indices.size());
    // double sx=0, sy=0, sz=0;
    for (std::vector<int>::const_iterator pit = cluster_indices[i].indices.begin();
        pit != cluster_indices[i].indices.end(); ++pit)
    {
      objCluster[i]->points.push_back(cloud_in->points[*pit]);
      // sx+=cloud_in->points[*pit].x;
      // sy+=cloud_in->points[*pit].y;
      // sz+=cloud_in->points[*pit].z;
      //TODO Calcular pose
    }
    // int nsize=objCluster[i]->points.size();
    objCluster[i]->width = objCluster[i]->points.size();
    objCluster[i]->height = 1;
    objCluster[i]->is_dense = true;
    objCluster[i]->header =  cloud_in->header;
    //ROS_DEBUG_STREAM("Cluster " << i+1 << " with " << objCluster[i]->points.size());
   // ROS_INFO_STREAM("Pose " << sx/nsize << ", " << sy/nsize << ", "<< sz/nsize );
  }

  return objCluster;
}


CommBasicObjects::CommPosition3d CaptureSensor::get_pose(PointCloud::Ptr  cloud_in) {

	CommBasicObjects::CommPosition3d pose_out;
	float sx=0, sy=0, sz=0;
	int n=0;

	 for(size_t i = 0; i <   cloud_in->points.size(); ++i)
    {
      sx+=cloud_in->points[i].x;
      sy+=cloud_in->points[i].y;
      sz+=cloud_in->points[i].z;
      n++;

    }
    pose_out.setX(float(sx/n)).setY(float(sy/n)).setZ(float(sz/n));

    return pose_out;
}

