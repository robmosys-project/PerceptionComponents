//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "CaptureSensor.hh"
#include "ObjectDetection.hh"

#include <iostream>

CaptureSensor::CaptureSensor(SmartACE::SmartComponent *comp) 
:	CaptureSensorCore(comp)
{
	std::cout << "constructor CaptureSensor\n";
}
CaptureSensor::~CaptureSensor() 
{
	std::cout << "destructor CaptureSensor\n";
}

cv::Mat CaptureSensor::get_Mat(const DomainVision::CommVideoImage input){

	const unsigned char *color_frame;

	color_frame = input.get_data();

	const int w = input.get_width();
	const int h = input.get_height();

	cv::Mat image(cv::Size(w, h), CV_8UC3, (void*)input.get_data());
	cv::imshow("CommVideoImage", image);
	cv::waitKey(10);

	return image;
}

cv::Mat CaptureSensor::Segmentation(cv::Mat img){

//    cv::Mat segmented_image = img;
    //Converting image from BGR to HSV color space.
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);

    cv::Mat mask1,mask2;
    // Creating masks to detect the upper and lower red color.
    cv::inRange(hsv, cv::Scalar(0, 120, 70), cv::Scalar(10, 255, 255), mask1);
    cv::inRange(hsv, cv::Scalar(170, 120, 70), cv::Scalar(180, 255, 255), mask2);

	// Generating the final mask to detect red color
	mask1 = mask1+mask2;
	cv::imshow("mask1", mask1);
	cv::waitKey(10);
    return mask1;
}

//Entregar punto del blob mas grande encontrado
cv::Point CaptureSensor::Countour(cv::Mat mask){

    int largest_area=0;
    int largest_contour_index=0;

    std::vector< std::vector<cv::Point> > contours; // Vector for storing contour
    std::vector<cv::Vec4i> hierarchy;

    cv::findContours( mask, contours, hierarchy,CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE ); // Find the contours in the image

    for( int i = 0; i< contours.size(); i++ ) {// iterate through each contour.
        double a=contourArea( contours[i],false);  //  Find the area of contour
        if(a>largest_area){
            largest_area=a;
            largest_contour_index=i;                //Store the index of largest contour
            //bounding_rect=boundingRect(contours[i]); // Find the bounding rectangle for biggest contour
        }
    }

	/// Get the center
	cv::Moments mu;
	cv::Point mc;
	mu = moments( contours[largest_contour_index], false );
	mc = cv::Point( mu.m10/mu.m00 , mu.m01/mu.m00 );

//	std::cout<<"[CaptureSensor] Center biggest blob : "<<mc.x<<", "<<mc.y<<std::endl;
//
//    cv::Mat matImage = cv::Mat::zeros( mask.size(), CV_8UC1 );
//    cv::drawContours( matImage, contours, largest_contour_index, cv::Scalar(255), CV_FILLED, 8, hierarchy ); // Draw the largest contour using previously stored index.
//	 cv::circle( matImage, mc, 4, cv::Scalar(255), -1, 8, 0 );
//	cv::imshow("mask_contour", matImage);
//	cv::waitKey(10);

    return mc;
}


void CaptureSensor::on_RGBDImagePushServiceIn(const DomainVision::CommRGBDImage &input)
{
	// upcall triggered from InputPort RGBDImagePushServiceIn
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort RGBDImagePushServiceIn
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method rGBDImagePushServiceInGetUpdate(input) to get a copy of the input object
	this->rGBDImagePushServiceInStatus = Smart::SMART_OK;
	this->rGBDImagePushServiceInObject = input;

}

int CaptureSensor::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	return 0;
}

int CaptureSensor::on_execute()
{
	Smart::StatusCode status;
	DomainVision::CommRGBDImage rGBDImagePushServiceInObject;
	status = this->rGBDImagePushServiceInGetUpdate(rGBDImagePushServiceInObject);

	if(status != Smart::SMART_OK)
		 return 0;

	DomainVision::CommVideoImage colorImage = rGBDImagePushServiceInObject.getColor_image();
	COMP->setVideoImage(colorImage);
	std::vector<unsigned char> image_date;
	image_date = colorImage.getDataRef();
//	std::cout << "[Image Task] on_execute data "<< image_date.size()<< std::endl;

	cv::Mat image = get_Mat(colorImage);
	cv::Mat mask = Segmentation(image);
	cv::Point p_object = Countour(mask);

//	cv::imshow("Segmentation mask", mask);
//	cv::waitKey(10);

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}

int CaptureSensor::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
